<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Dekha — Starry Roshni</title>
<style>
  :root{
    --bg:#02030a;
    --text:#eaf7ff;
    --hint:#c9d6e8;
  }
  html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,system-ui,Arial;color:var(--text);-webkit-font-smoothing:antialiased}
  #app{position:relative;height:100vh;overflow:hidden}
  video#cam{position:fixed;inset:0;width:100%;height:100%;object-fit:cover;transform:scaleX(-1);
    filter:brightness(0.46) contrast(1.02) saturate(0.98);z-index:1}
  canvas#fx{position:fixed;inset:0;width:100%;height:100%;pointer-events:none;mix-blend-mode:screen;z-index:20}
  .overlay{position:fixed;inset:0;z-index:30;pointer-events:none}
  .ui{position:fixed;left:50%;transform:translateX(-50%);bottom:22px;text-align:center;z-index:1000;pointer-events:auto;transition:opacity 260ms ease, transform 260ms ease}
  #start{background:linear-gradient(180deg,#f8fbff,#eaf6ff);color:#071026;border-radius:999px;padding:12px 18px;font-size:16px;border:none;box-shadow:0 8px 26px rgba(2,6,20,0.45)}
  .hint{font-size:12px;color:var(--hint);margin-top:8px;opacity:0.95}
  .msg{position:fixed;left:50%;transform:translateX(-50%) translateY(10px);bottom:60px;z-index:50;font-size:14px;padding:6px 12px;opacity:0;
    transition:opacity 600ms ease, transform 600ms cubic-bezier(.2,.9,.2,1);color:var(--text);text-align:center;border-radius:10px;backdrop-filter: blur(4px);pointer-events:none}
  .msg.glow{background: rgba(10,14,26,0.34);box-shadow:0 10px 36px rgba(3,8,20,0.6)}
  .hidden { opacity: 0; transform: translateY(10px) scale(.98); pointer-events: none; }
  .sparkle-layer{position:fixed;inset:0;pointer-events:none;z-index:24;mix-blend-mode:screen}
  @media (min-width:900px){ .msg{font-size:16px; bottom:84px} #start{font-size:18px;padding:14px 22px} }
</style>
</head>
<body>
<div id="app">
  <video id="cam" playsinline autoplay muted></video>
  <canvas id="fx"></canvas>

  <div class="overlay">
    <div class="msg" id="msg" aria-hidden="true">Dekha, roshni ho gayi har jagah ✨</div>
    <div class="sparkle-layer" id="sparks"></div>
  </div>

  <div class="ui" id="ui" role="button" aria-label="Start overlay">
    <button id="start">Tap anywhere to begin</button>
    <div class="hint" id="hint">Best after sunset. Allow camera access and gently tilt your phone.</div>
  </div>
</div>

<script>
(async function(){
  // elements
  const video = document.getElementById('cam');
  const canvas = document.getElementById('fx');
  const ctx = canvas.getContext('2d', { alpha: true });
  const startBtn = document.getElementById('start');
  const ui = document.getElementById('ui');
  const hint = document.getElementById('hint');
  const msg = document.getElementById('msg');
  const sparksLayer = document.getElementById('sparks');

  // size
  let w = canvas.width = innerWidth;
  let h = canvas.height = innerHeight;
  addEventListener('resize', ()=>{ w = canvas.width = innerWidth; h = canvas.height = innerHeight; });

  // get camera
  let cameraGranted = false;
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio:false });
    video.srcObject = stream;
    cameraGranted = true;
    hint.classList.add('hidden');
  } catch(e){
    console.error(e);
    // camera may be blocked — keep UI visible so user knows to allow permission
  }

  // speck data: starry cooler palette
  let stars = [], running = false;

  function makeStar(x,y){
    return {
      x, y,
      vx: (Math.random()*0.18-0.09),
      vy: (Math.random()*-0.06-0.02), // gentle upward drift
      life: 200 + Math.random()*280,
      r: 0.6 + Math.random()*1.4,
      tw: Math.random()*Math.PI*2,
      baseAlpha: 0.5 + Math.random()*0.45,
      hueShift: Math.random()*20 - 10, // use to slightly tint blue
      twinkleSpeed: 0.008 + Math.random()*0.018
    };
  }

  function spawnStarsInArea(x1,x2,y1,y2,qty=6){
    for(let i=0;i<qty;i++){
      const x = x1 + Math.random()*(x2-x1);
      const y = y1 + Math.random()*(y2-y1);
      stars.push(makeStar(x,y));
    }
    if(stars.length > 1200) stars.splice(0, stars.length - 900);
  }

  // wide initial scatter (top-heavy)
  function scatterWide(){
    // spawn across width, bias top 70%
    for(let i=0;i<180;i++){
      const x = Math.random()*w;
      const y = Math.random() < 0.75 ? Math.random()* (h*0.65) : (h*0.65 + Math.random()*h*0.35);
      stars.push(makeStar(x,y));
    }
  }

  // device orientation target
  let orientTarget = null, lastOrient = { x:w/2, y:h*0.35 };
  function setTargetFromOrientation(a,b,g){
    const nx = (0.5 + (g||0)/90 * 0.45) * w;
    const ny = (0.25 + (b||0)/180 * 0.45) * h;
    orientTarget = { x:nx, y:ny };
  }
  if(window.DeviceOrientationEvent){
    window.addEventListener('deviceorientation', (ev)=>{ setTargetFromOrientation(ev.alpha, ev.beta||0, ev.gamma||0); }, true);
  }

  // draw loop (starry cooler tones)
  function step(){
    ctx.clearRect(0,0,w,h);
    // gentle dark overlay to retain subtle trails
    ctx.fillStyle = 'rgba(0,0,0,0.04)'; ctx.fillRect(0,0,w,h);

    for(let i=stars.length-1;i>=0;i--){
      const s = stars[i];
      s.tw += s.twinkleSpeed;
      // gentle noise motion
      s.x += s.vx + Math.sin(s.tw)*0.06;
      s.y += s.vy + Math.cos(s.tw)*0.02;
      s.life--;
      // twinkle factor oscillates
      const t = 0.5 + 0.5*Math.sin(s.tw*2.1);
      const lifeFactor = Math.max(0, Math.min(1, s.life / 420));
      const alpha = Math.min(1, s.baseAlpha * (0.6 + 0.6*t) * lifeFactor);

      // star color: cool white core, pale blue halo
      const core = `rgba(${230 - (s.hueShift|0)}, ${240 - (s.hueShift|0)}, 255, ${alpha})`;
      const halo = `rgba(190,210,255,${Math.max(0.18, 0.12 * lifeFactor * (0.9 + t))})`;

      const glow = 10 + s.r*8;
      const g = ctx.createRadialGradient(s.x,s.y,0,s.x,s.y,glow);
      g.addColorStop(0, core);
      g.addColorStop(0.35, halo);
      g.addColorStop(1, 'rgba(0,0,0,0)');

      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(s.x,s.y, Math.max(1.2, s.r*4.6), 0, Math.PI*2);
      ctx.fill();
      ctx.globalCompositeOperation = 'source-over';

      if(s.life <= 0 || s.x < -80 || s.x > w+80 || s.y < -120) stars.splice(i,1);
    }

    requestAnimationFrame(step);
  }
  step();

  // subtle DOM sparkles (complementary tiny stars)
  function renderDOMSparks(){
    sparksLayer.innerHTML = '';
    const n = 26;
    for(let i=0;i<n;i++){
      const el = document.createElement('div');
      const s = 4 + Math.random()*10;
      el.style.position='absolute';
      el.style.left=(Math.random()*100) + '%';
      el.style.top=(Math.random()*75) + '%';
      el.style.width=s+'px'; el.style.height=s+'px';
      el.style.borderRadius='50%';
      el.style.background='radial-gradient(circle, rgba(245,250,255,0.95), rgba(200,220,255,0.18))';
      el.style.filter='blur(4px)'; el.style.opacity=(0.06 + Math.random()*0.28)+'';
      sparksLayer.appendChild(el);
    }
  }
  renderDOMSparks(); setInterval(renderDOMSparks, 4800);

  // orientation-follow spawn (gentle) and random spread
  setInterval(()=>{
    // prefer orient target if available
    let sx, sy;
    if(orientTarget){
      lastOrient.x += (orientTarget.x - lastOrient.x) * 0.18;
      lastOrient.y += (orientTarget.y - lastOrient.y) * 0.18;
      // spawn near that area with spread
      sx = lastOrient.x + (Math.random()*240-120);
      sy = lastOrient.y + (Math.random()*120-60);
      spawnStarsInArea(Math.max(40, sx-120), Math.min(w-40, sx+120), Math.max(20, sy-80), Math.min(h-40, sy+80), 6 + Math.floor(Math.random()*6));
    } else {
      // spawn across wide top area with good spacing
      const x1 = 20, x2 = w-20;
      const y1 = 20, y2 = Math.max(60, h*0.65); // bias upper region
      spawnStarsInArea(x1, x2, y1, y2, 12 + Math.floor(Math.random()*10));
    }
    // occasional sea of spaced stars
    if(Math.random() < 0.06) spawnStarsInArea(20, w-20, 20, Math.max(60, h*0.6), 40 + Math.floor(Math.random()*30));
  }, 420);

  // convenience spawn method using area coordinates
  function spawnStarsInArea(x1, x2, y1, y2, qty=8){
    for(let i=0;i<qty;i++){
      const x = x1 + Math.random()*(x2-x1);
      const y = y1 + Math.random()*(y2-y1);
      stars.push(makeStar(x,y));
    }
    if(stars.length > 1200) stars.splice(0, stars.length - 900);
  }

  // start behavior: hide UI, scatter wide, show msg after 4s
  function begin(){
    if(running) return;
    running = true;
    ui.classList.add('hidden');
    hint.classList.add('hidden');

    // immediate soft scatter across top
    scatterWide();

    // message after 4 seconds
    setTimeout(()=>{ msg.classList.add('glow'); msg.style.opacity = 1; msg.style.transform='translateX(-50%) translateY(0)'; msg.setAttribute('aria-hidden','false'); }, 4000);

    // gentle ongoing spawn ramp for first 18s
    const ramp = setInterval(()=>{
      // spawn across very wide top with spacing
      spawnStarsInArea(20, w-20, 20, Math.max(60, h*0.65), 22 + Math.floor(Math.random()*8));
    }, 900);
    setTimeout(()=>clearInterval(ramp), 18000);
  }

  // wire taps reliably
  startBtn.addEventListener('click', begin, {passive:true});
  canvas.addEventListener('touchstart', begin, {passive:true});
  document.body.addEventListener('touchstart', begin, {passive:true});
  document.body.addEventListener('click', begin, {passive:true});

  // if camera not granted, keep hint visible until user allows
  if(!cameraGranted) hint.classList.remove('hidden');
})();
</script>
</body>
</html>
